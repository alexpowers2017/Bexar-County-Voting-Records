inherit = ElectionReport,
public = list(
lines_df = NULL,
### DOWNLOADING REPORT ###
download_and_create_lines_df = function() {
self$download_pdf()
self$create_lines_df()
},
download_pdf = function() {
download.file(self$url, self$get_file_path() , mode='wb')
},
create_lines_df = function() {
self$lines_df <-
pdftools::pdf_text(self$get_file_path()) %>%    # Reads the PDF file (must already be downloaded) to char list
self$collapse_pages() %>%                       # Creates char vect - each PDF line is an element
base::as.data.frame() %>%
dplyr::rename(lines = '.')                      # Convert to one-column dataframe with the column name 'lines'
},
# Election report PDFs are read in as lists with each page as an element.
collapse_pages = function(file_text) {
single_string <- stringr::str_c(file_text, collapse="\n")  # Collapse all pages into one string, separated by \n
lines <- stringr::str_split(single_string, '\n')[[1]]       # Reads each line as an element in a char vector
return(lines)
},
### PROCCESSING LINES DF ###
identify_lines = function() {
df <- self$lines_df %>%
transform(
type = ifelse(private$is_office(lines), 'office',
ifelse(private$is_precinct(lines), 'precinct',
ifelse(private$is_result(lines), 'result',
ifelse(private$is_useless_line(lines), 'useless',
NA ))))
)
return(df)
}
), # END PUBLIC
private = list(
# 'Office' is the hardest one to get - I basically had to identify every
#   other kind of line that would be in the report, and if it doesn't match
#   those and includes at least two words, I call it an office.
# TODO: First build out offices I'm interested in, then identify offices from a base set of data.
is_office = function(line) {
result <- stringr::str_detect(line, '[A-Za-z]+\\W?\\s+[A-Za-z]+') &
!is_precinct(line) &
!is_result(line) &
!is_useless_line(line)
return(result)
},
is_precinct = function(line) {
return(stringr::str_detect(line, '^\\d{3,5}$')) # Line whose only value is 3-5 consecutive digits
},
# A 'result' line will contain the candidates name and vote totals
is_result = function(line) {
# Checks that row contains 4 sequences of digits/punctuation separated by spaces. Doesn't pick up under/overvotes
return(stringr::str_detect(line, '[\\d|\\W]+\\s+[\\d|\\W]+\\s+[\\d|\\W]+\\s+[\\d|\\W]+'))
},
# Identifies all lines that don't provide any information we're interested in
is_useless_line = function(line) {
result <- is_blank(line) |
is_header_footer(line) |
is_vote_for(line) |
is_col_name(line)
return(result)
},
is_blank = function(line) {
return(stringr::str_trim(line) == '')
},
is_header_footer = function(line) {
result <- stringr::str_detect(line, '[A-Za-z]{3,9}\\s\\d{1,2}\\W\\s\\d{2,4}') |  # Date at top of each page
stringr::str_detect(line, 'OFFICIAL\\sRESULTS$') |      # line ends with 'OFFICIAL RESULTS'
stringr::str_detect(line, '^.+Election$') |             # Line ends with 'Election' - 2nd line in header
stringr::str_detect(line, 'Summary.+\\d\\sof\\s\\d') |  # line contains both 'Summary' and '# of #' - page number in footer
stringr::str_detect(line, 'Report generated with')      # Bottom line of footer showing the software the report was made with
return(result)
},
is_vote_for = function(line) {
return(stringr::str_detect(line, 'Vote\\sFor\\s\\d'))
},
is_col_name = function(line) {
result <- stringr::str_detect(line, "^\\s+TOTAL\\s+VOTE.+Election\\s+Absentee\\s+Early$") |
stringr::str_detect(line, "^\\s+Day\\s+Voting$")
return(result)
}
) # end private
) # end ElectionReport_BexarPDF definition
report1 <- ElectionReport_BexarPDF$new(elections_metadata[3,])
report1$download_and_create_lines_df()
id_df <- report1$identify_lines()
# This object is a superclass which will contain all the information about
#   an election report and parse the data it contains
ElectionReport <- R6Class('ElectionReport',
public = list(
description = NULL,
date = NULL,
election_type = NULL,
county = NULL,
url = NULL,
report_type = NULL,
party = NULL,
# the input to initialize this object will be a row from the elections metadata .csv file
initialize = function(row) {
self$description <- row$description
self$date <- row$date
self$election_type <- row$election_type
self$county <- row$county
self$url <- row$url
self$report_type <- row$report_type
self$party <-
ifelse( stringr::str_detect(self$description, 'epublican'), 'R',
ifelse( stringr::str_detect(self$description, 'emocrat'), 'D',
NA ))
self$describe()
},
get_file_path = function() {
return(stringr::str_glue("data/election_reports/{self$description} {self$date}.pdf"))
},
describe = function() {
message('\n----- REPORT OBJECT -----')
message(stringr::str_glue('
Description:   {self$description}
Date:          {self$date}
Election Type: {self$election_type}
Party:         {self$party}
Report Type:   {self$report_type}
Report Type:   {self$report_type}
County:        {self$county}
URL:           {self$url}'
))
message('-------------------------\n')
}
) # end public
) # end ElectionReport definition
ElectionReport_BexarPDF <- R6Class('ElectionReport_BexarPDF',
inherit = ElectionReport,
public = list(
lines_df = NULL,
### DOWNLOADING REPORT ###
download_and_create_lines_df = function() {
self$download_pdf()
self$create_lines_df()
},
download_pdf = function() {
download.file(self$url, self$get_file_path() , mode='wb')
},
create_lines_df = function() {
self$lines_df <-
pdftools::pdf_text(self$get_file_path()) %>%    # Reads the PDF file (must already be downloaded) to char list
self$collapse_pages() %>%                       # Creates char vect - each PDF line is an element
base::as.data.frame() %>%
dplyr::rename(lines = '.')                      # Convert to one-column dataframe with the column name 'lines'
},
# Election report PDFs are read in as lists with each page as an element.
collapse_pages = function(file_text) {
single_string <- stringr::str_c(file_text, collapse="\n")  # Collapse all pages into one string, separated by \n
lines <- stringr::str_split(single_string, '\n')[[1]]       # Reads each line as an element in a char vector
return(lines)
},
### PROCCESSING LINES DF ###
identify_lines = function() {
df <- self$lines_df %>%
transform(
type = ifelse(private$is_office(lines), 'office',
ifelse(private$is_precinct(lines), 'precinct',
ifelse(private$is_result(lines), 'result',
ifelse(private$is_useless_line(lines), 'useless',
NA ))))
)
return(df)
}
), # END PUBLIC
private = list(
# 'Office' is the hardest one to get - I basically had to identify every
#   other kind of line that would be in the report, and if it doesn't match
#   those and includes at least two words, I call it an office.
# TODO: First build out offices I'm interested in, then identify offices from a base set of data.
is_office = function(line) {
result <- stringr::str_detect(line, '[A-Za-z]+\\W?\\s+[A-Za-z]+') &
!private$is_precinct(line) &
!private$is_result(line) &
!private$is_useless_line(line)
return(result)
},
is_precinct = function(line) {
return(stringr::str_detect(line, '^\\d{3,5}$')) # Line whose only value is 3-5 consecutive digits
},
# A 'result' line will contain the candidates name and vote totals
is_result = function(line) {
# Checks that row contains 4 sequences of digits/punctuation separated by spaces. Doesn't pick up under/overvotes
return(stringr::str_detect(line, '[\\d|\\W]+\\s+[\\d|\\W]+\\s+[\\d|\\W]+\\s+[\\d|\\W]+'))
},
# Identifies all lines that don't provide any information we're interested in
is_useless_line = function(line) {
result <- private$is_blank(line) |
private$is_header_footer(line) |
private$is_vote_for(line) |
private$is_col_name(line)
return(result)
},
is_blank = function(line) {
return(stringr::str_trim(line) == '')
},
is_header_footer = function(line) {
result <- stringr::str_detect(line, '[A-Za-z]{3,9}\\s\\d{1,2}\\W\\s\\d{2,4}') |  # Date at top of each page
stringr::str_detect(line, 'OFFICIAL\\sRESULTS$') |      # line ends with 'OFFICIAL RESULTS'
stringr::str_detect(line, '^.+Election$') |             # Line ends with 'Election' - 2nd line in header
stringr::str_detect(line, 'Summary.+\\d\\sof\\s\\d') |  # line contains both 'Summary' and '# of #' - page number in footer
stringr::str_detect(line, 'Report generated with')      # Bottom line of footer showing the software the report was made with
return(result)
},
is_vote_for = function(line) {
return(stringr::str_detect(line, 'Vote\\sFor\\s\\d'))
},
is_col_name = function(line) {
result <- stringr::str_detect(line, "^\\s+TOTAL\\s+VOTE.+Election\\s+Absentee\\s+Early$") |
stringr::str_detect(line, "^\\s+Day\\s+Voting$")
return(result)
}
) # end private
) # end ElectionReport_BexarPDF definition
report1 <- ElectionReport_BexarPDF$new(elections_metadata[3,])
report1$download_and_create_lines_df()
id_df <- report1$identify_lines()
head(id_df, 40)
ElectionReport_BexarPDF <- R6Class('ElectionReport_BexarPDF',
inherit = ElectionReport,
public = list(
lines_df = NULL,
### DOWNLOADING REPORT ###
download_and_create_lines_df = function() {
self$download_pdf()
self$create_lines_df()
},
download_pdf = function() {
download.file(self$url, self$get_file_path() , mode='wb')
},
create_lines_df = function() {
self$lines_df <-
pdftools::pdf_text(self$get_file_path()) %>%    # Reads the PDF file (must already be downloaded) to char list
self$collapse_pages() %>%                       # Creates char vect - each PDF line is an element
base::as.data.frame() %>%
dplyr::rename(lines = '.')                      # Convert to one-column dataframe with the column name 'lines'
},
# Election report PDFs are read in as lists with each page as an element.
collapse_pages = function(file_text) {
single_string <- stringr::str_c(file_text, collapse="\n")  # Collapse all pages into one string, separated by \n
lines <- stringr::str_split(single_string, '\n')[[1]]       # Reads each line as an element in a char vector
return(lines)
},
### PROCCESSING LINES DF ###
identify_lines = function() {
df <- self$lines_df %>%
transform(
type = ifelse(private$is_office(lines), 'office',
ifelse(private$is_precinct(lines), 'precinct',
ifelse(private$is_result(lines), 'result',
ifelse(private$is_useless_line(lines), 'useless',
NA ))))
)
return(df)
}
), # END PUBLIC
private = list(
# 'Office' is the hardest one to get - I basically had to identify every
#   other kind of line that would be in the report, and if it doesn't match
#   those and includes at least two words, I call it an office.
# TODO: First build out offices I'm interested in, then identify offices from a base set of data.
is_office = function(line) {
result <- stringr::str_detect(line, '[A-Za-z]+\\W?\\s+[A-Za-z]+') &
!private$is_precinct(line) &
!private$is_result(line) &
!private$is_useless_line(line)
return(result)
},
is_precinct = function(line) {
return(stringr::str_detect(line, '^\\d{3,5}$')) # Line whose only value is 3-5 consecutive digits
},
# A 'result' line will contain the candidates name and vote totals
is_result = function(line) {
# Checks that row contains 4 sequences of digits/punctuation separated by spaces. Doesn't pick up under/overvotes
return(stringr::str_detect(line, '[\\d|[:punct:]]+\\s+[\\d|[:punct:]]+\\s+[\\d|[:punct:]]+\\s+[\\d|\\W]+'))
},
# Identifies all lines that don't provide any information we're interested in
is_useless_line = function(line) {
result <- private$is_blank(line) |
private$is_header_footer(line) |
private$is_vote_for(line) |
private$is_col_name(line)
return(result)
},
is_blank = function(line) {
return(stringr::str_trim(line) == '')
},
is_header_footer = function(line) {
result <- stringr::str_detect(line, '[A-Za-z]{3,9}\\s\\d{1,2}\\W\\s\\d{2,4}') |  # Date at top of each page
stringr::str_detect(line, 'OFFICIAL\\sRESULTS$') |      # line ends with 'OFFICIAL RESULTS'
stringr::str_detect(line, '^.+Election$') |             # Line ends with 'Election' - 2nd line in header
stringr::str_detect(line, 'Summary.+\\d\\sof\\s\\d') |  # line contains both 'Summary' and '# of #' - page number in footer
stringr::str_detect(line, 'Report generated with')      # Bottom line of footer showing the software the report was made with
return(result)
},
is_vote_for = function(line) {
return(stringr::str_detect(line, 'Vote\\sFor\\s\\d'))
},
is_col_name = function(line) {
result <- stringr::str_detect(line, "\\s+TOTAL\\s+VOTE.+Election\\s+Absentee\\s+Early") |
stringr::str_detect(line, "\\s+Day\\s+Voting")
return(result)
}
) # end private
) # end ElectionReport_BexarPDF definition
report1 <- ElectionReport_BexarPDF$new(elections_metadata[3,])
report1$download_and_create_lines_df()
id_df <- report1$identify_lines()
head(id_df, 40)
rm(list=ls()
)
library(R6)
library(stringr)
library(dplyr)
library(pdftools)
# This object is a superclass which will contain all the information about
#   an election report and parse the data it contains
ElectionReport <- R6Class('ElectionReport',
public = list(
description = NULL,
date = NULL,
election_type = NULL,
county = NULL,
url = NULL,
report_type = NULL,
party = NULL,
# the input to initialize this object will be a row from the elections metadata .csv file
initialize = function(row) {
self$description <- row$description
self$date <- row$date
self$election_type <- row$election_type
self$county <- row$county
self$url <- row$url
self$report_type <- row$report_type
self$party <-
ifelse( stringr::str_detect(self$description, 'epublican'), 'R',
ifelse( stringr::str_detect(self$description, 'emocrat'), 'D',
NA ))
self$describe()
},
get_file_path = function() {
return(stringr::str_glue("data/election_reports/{self$description} {self$date}.pdf"))
},
describe = function() {
message('\n----- REPORT OBJECT -----')
message(stringr::str_glue('
Description:   {self$description}
Date:          {self$date}
Election Type: {self$election_type}
Party:         {self$party}
Report Type:   {self$report_type}
Report Type:   {self$report_type}
County:        {self$county}
URL:           {self$url}'
))
message('-------------------------\n')
}
) # end public
) # end ElectionReport definition
ElectionReport_BexarPDF <- R6Class('ElectionReport_BexarPDF',
inherit = ElectionReport,
public = list(
lines_df = NULL,
### DOWNLOADING REPORT ###
download_and_create_lines_df = function() {
self$download_pdf()
self$create_lines_df()
},
download_pdf = function() {
download.file(self$url, self$get_file_path() , mode='wb')
},
create_lines_df = function() {
self$lines_df <-
pdftools::pdf_text(self$get_file_path()) %>%    # Reads the PDF file (must already be downloaded) to char list
self$collapse_pages() %>%                       # Creates char vect - each PDF line is an element
base::as.data.frame() %>%
dplyr::rename(lines = '.')                      # Convert to one-column dataframe with the column name 'lines'
},
# Election report PDFs are read in as lists with each page as an element.
collapse_pages = function(file_text) {
single_string <- stringr::str_c(file_text, collapse="\n")  # Collapse all pages into one string, separated by \n
lines <- stringr::str_split(single_string, '\n')[[1]]       # Reads each line as an element in a char vector
return(lines)
},
### PROCCESSING LINES DF ###
identify_lines = function() {
df <- self$lines_df %>%
transform(
type = ifelse(private$is_office(lines), 'office',
ifelse(private$is_precinct(lines), 'precinct',
ifelse(private$is_result(lines), 'result',
ifelse(private$is_useless_line(lines), 'useless',
NA ))))
)
return(df)
}
), # END PUBLIC
private = list(
# 'Office' is the hardest one to get - I basically had to identify every
#   other kind of line that would be in the report, and if it doesn't match
#   those and includes at least two words, I call it an office.
# TODO: First build out offices I'm interested in, then identify offices from a base set of data.
is_office = function(line) {
result <- stringr::str_detect(line, '[A-Za-z]+\\W?\\s+[A-Za-z]+') &
!private$is_precinct(line) &
!private$is_result(line) &
!private$is_useless_line(line)
return(result)
},
is_precinct = function(line) {
return(stringr::str_detect(line, '^\\d{3,5}$')) # Line whose only value is 3-5 consecutive digits
},
# A 'result' line will contain the candidates name and vote totals
is_result = function(line) {
# Checks that row contains 4 sequences of digits/punctuation separated by spaces. Doesn't pick up under/overvotes
return(stringr::str_detect(line, '[\\d|[:punct:]]+\\s+[\\d|[:punct:]]+\\s+[\\d|[:punct:]]+\\s+[\\d|\\W]+'))
},
# Identifies all lines that don't provide any information we're interested in
is_useless_line = function(line) {
result <- private$is_blank(line) |
private$is_header_footer(line) |
private$is_vote_for(line) |
private$is_col_name(line)
return(result)
},
is_blank = function(line) {
return(stringr::str_trim(line) == '')
},
is_header_footer = function(line) {
result <- stringr::str_detect(line, '[A-Za-z]{3,9}\\s\\d{1,2}\\W\\s\\d{2,4}') |  # Date at top of each page
stringr::str_detect(line, 'OFFICIAL\\sRESULTS$') |      # line ends with 'OFFICIAL RESULTS'
stringr::str_detect(line, '^.+Election$') |             # Line ends with 'Election' - 2nd line in header
stringr::str_detect(line, 'Summary.+\\d\\sof\\s\\d') |  # line contains both 'Summary' and '# of #' - page number in footer
stringr::str_detect(line, 'Report generated with')      # Bottom line of footer showing the software the report was made with
return(result)
},
is_vote_for = function(line) {
return(stringr::str_detect(line, 'Vote\\sFor\\s\\d'))
},
is_col_name = function(line) {
result <- stringr::str_detect(line, "\\s+TOTAL\\s+VOTE.+Election\\s+Absentee\\s+Early") |
stringr::str_detect(line, "\\s+Day\\s+Voting")
return(result)
}
) # end private
) # end ElectionReport_BexarPDF definition
library(lubridate)
library(dplyr)
# Read in csv file I put together with report urls and other info for each election
elections_metadata <- utils::read.csv('data/manually_created/Election Totals Report urls.csv') %>%
transform(date = lubridate::mdy(date)) %>%
dplyr::filter(report_type != '')  # Only working with a subset of reports that I've already categorized by layout and format
elections_metadata
report1 <- ElectionReport_BexarPDF$new(elections_metadata[1,])
report1$download_and_create_lines_df()
str(report1$lines_df)
a <- report1$identify_lines()
a
a[43,1]
a[44,1]
a[45,1]
a[48,1]
a[47,1]
a[49,1]
a[375,1]
a[376,1]
a[377,1]
a[378,1]
install.packages('testthat')
library(testthat)
install.packages('usethis')
library(usethis)
usethis::use_test('Report Classes')
usethis::use_test('report_classes')
?usethis
?use
x <- c('example description',mdy('5-5-2025'), 'example election type','example report type','www.mywebsite.com')
x
as.data.frame(x)
matrix(data=c('example description',mdy('5-5-2025'), 'example election type','example report type','www.mywebsite.com'), nrow=1, ncol=5)
a <- data.frame()
a$description <- 'example description'
a <- as.data.frame(matrix(nrow=0, ncol=0))
a <- as.data.frame(matrix(nrow=1, ncol=0))
a$description <- 'example description'
a
a$date <- lubridate::mdy('September-4-2020')
a
example_row <- as.data.frame(matrix(nrow=1, ncol=0))
example_row$description <- 'example description'
example_row$date <- lubridate::mdy('September-4-2020')
example_row$election_type <- 'example election type'
example_row$report_type <- 'example report type'
example_row$county <- 'example county'
example_row$url <- 'www.example.com'
example_row
dplyr::tribble(
~col1, ~col2,
'hello', 'there'
)
dplyr::tribble(
~col1, ~col2,
'hello', 'there'
) %>% as.data.frame()
install.packages('rtools')
install.packages('Rtools')
