
library(R6)
library(stringr)
library(dplyr)
library(pdftools)



ElectionReport_BexarPDF <- R6Class('ElectionReport_BexarPDF',
    inherit = ElectionReport,
    public = list(
        
        lines_df = NULL,
        
        
        ### DOWNLOADING REPORT ###
        
        download_and_create_lines_df = function() {
            download.file(self$url, self$get_file_path() , mode='wb')
            self$create_lines_df()
        },
            
            create_lines_df = function() { 
                self$lines_df <- 
                    pdftools::pdf_text(self$get_file_path()) %>%    # Reads the PDF file (must already be downloaded) to char list 
                    self$collapse_pages() %>%                       # Creates char vect - each PDF line is an element
                    base::as.data.frame() %>%     
                    dplyr::rename(lines = '.')                      # Convert to one-column dataframe with the column name 'lines'
            },
            
                # Election report PDFs are read in as lists with each page as an element.
                collapse_pages = function(file_text) {
                    single_string <- stringr::str_c(file_text, collapse="\n")  # Collapse all pages into one string, separated by \n
                    lines <- stringr::str_split(single_string, '\n')[[1]]       # Reads each line as an element in a char vector
                    return(lines)
                },
        
        
        ### PROCCESSING LINES DF ###
        
        identify_lines = function() {
            df <- self$lines_df %>%
                transform(
                    type = ifelse(self$is_office(lines), 'office',
                        ifelse(self$is_precinct(lines), 'precinct',
                        ifelse(self$is_result(lines), 'result',
                        ifelse(self$is_useless_line(lines), 'useless',
                        NA ))))
                )
            return(df)
        },
        
        
        # 'Office' is the hardest one to get - I basically had to identify every 
        #   other kind of line that would be in the report, and if it doesn't match 
        #   those and includes at least two words, I call it an office. 
        is_office = function(line) {
            result <- stringr::str_detect(line, '[A-Za-z]+\\W?\\s+[A-Za-z]+') &
                !self$is_precinct(line) & 
                !self$is_result(line) & 
                !self$is_useless_line(line)
            return(result)
        },
            
            is_precinct = function(line) {
                return(stringr::str_detect(line, '^\\d{3,5}$')) # Line whose only value is 3-5 consecutive digits
            },
            
            # A 'result' line will contain the candidates name and vote totals
            is_result = function(line) {
                # Checks that row contains 3-4 sequences of digits/punctuation separated by spaces. Will pick up under/overvotes
                return(stringr::str_detect(line, '[\\d|[:punct:]]+\\s+[\\d|[:punct:]]+?\\s+[\\d|[:punct:]]+\\s+[\\d|\\W]+'))
            },
                
            # Identifies all lines that don't provide any information we're interested in
            is_useless_line = function(line) {
                result <- self$is_blank(line) |
                    self$is_header_footer(line) |
                    self$is_vote_for(line) |
                    self$is_col_name(line)
                return(result)
            },
        
                is_blank = function(line) {
                    return(stringr::str_trim(line) == '')
                },
                    
                is_header_footer = function(line) { 
                    result <- stringr::str_detect(line, '[A-Za-z]{3,9}\\s\\d{1,2}\\W\\s\\d{2,4}') |  # Date at top of each page 
                        stringr::str_detect(line, 'OFFICIAL\\sRESULTS$') |      # line ends with 'OFFICIAL RESULTS'
                        stringr::str_detect(line, '^.+Election$') |             # Line ends with 'Election' - 2nd line in header
                        stringr::str_detect(line, 'Summary.+\\d\\sof\\s\\d') |  # line contains both 'Summary' and '# of #' - page number in footer
                        stringr::str_detect(line, 'Report generated with')      # Bottom line of footer showing the software the report was made with
        
                    return(result)
                },
                    
                is_vote_for = function(line) {
                    return(stringr::str_detect(line, 'Vote\\sFor\\s\\d')) # Line contains "Vote For #"  
                },
                
                is_col_name = function(line) { 
                    result <- stringr::str_detect(line, "TOTAL\\s+VOTE.+Election\\s+Absentee\\s+Early") | 
                        stringr::str_detect(line, "\\s+Day\\s+Voting")
                    return(result)
                }
        
    ) # end public list 
    
) # end ElectionReport_BexarPDF definition



ElectionReport_BexarPDF_BS <- R6Class('ElectionReport_BexarPDF_BS',
    inherit = ElectionReport_BexarPDF,
    
    
    
    public = list (
        
        ## idk if this works
        is_result = function(line) {
            return(stringr::str_detect(line, '^[A-Za-z|\\s||[:punct:]]+\\s{15}\\s+\\d+$'))
        },
        
        is_precinct = function(line) {
            return(stringr::str_detect(self$remove_BS(line), '^\\d{3,5}$')) # Line whose only value is 3-5 consecutive digits
        },
        
            # removes " BS #(##...)" from string, which on precinct lines should leave only the precinct 
            remove_BS = function(line) {
                return(stringr::str_replace(line, '\\sBS\\s\\d+', '')) 
            }
    )
    
)




